[General idea]
1. Divide the problem into a number of subproblems.
2. Conquer the subproblems...
3. Combine the solutions to the subproblems into the original problem.

[Example] The maximum-subarray problem
Given a sequence, find the largest subsequence.

1. Brute-force solution;
    The answer is where begin and where end. So there are limited possibilities.
    Assume that the length of the sequence is n. We have C(n,2) pairs of dates.
2. Using divide-and-conquer;
    Suppose that we want to find a maximum subarray of the subarray A[low...high].
    Divide the subarray into two subarrays of as equal size as possible. So, consider
    A[low...mid] and A[mid+1...high].

    There are three conditions about the position of the solution:
    1. Entirely in the LEFT subarray.  [low i j mid]
    2. Entirely in the RIGHT subarray.[mid i j high]
    3. Crossing the midpoint.     [low i mid j high]

    Therefore, the maximum subarray of A[low...high] must be one of the three.
    In fact, the maximum subarray of A[low...high] must have the gretest sum over all subarrays
    entirely in LEFT subarray, entirely in RIGHT subarray or Crossing the midpoint.

    The problem is converted as, find the maximum-subarray of LEFT subarray and RIGHT subarray
    and the [rossing midpoint Problem]. The first two are exactly the same as the original
    problem.

    Then take a subarray with the largest sum of the three.

    Actually, we can easily find a maximum subarray crossing the midpoint in time linear in the 
    size of the subarray A[low...high]. It is composed of A[i...mid] and A[mid+1...j]. Therefore,
    we just need to find maximum subarray of the form A[i...mid] and A[mid+1...j] and combine
    them.   [Code] See file "Find-Max-Crossing Subarray.c"
